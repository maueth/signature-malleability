const EC = require("elliptic").ec;
const BN = require("bn.js");

const ec = new EC("secp256k1");
const ecparams = ec.curve;
const n = new BN(ecparams.n);

const privateKey = BigInt("5428737296356845297361273546856292754683629342");
const publicKey = ec.keyFromPrivate(privateKey);

/* X point
BN {
  negative: 0,
  words: [
    49813400, 10507973,
    42833311, 57456440,
    50502652, 60932801,
    33958236, 49197398,
    41875932,  1994649
  ],
  length: 10,
  red: Red {
    m: BN { negative: 0, words: [Array], length: 10, red: null },
    prime: K256 { name: 'k256', p: [BN], n: 256, k: [BN], tmp: [BN] }
  }
}
*/

/* Y point
BN {
  negative: 0,
  words: [
    51434680, 32777214,
    21076420, 19044885,
    16586676, 58999338,
    38780864, 51484022,
    41363107,  1183414
  ],
  length: 10,
  red: Red {
    m: BN { negative: 0, words: [Array], length: 10, red: null },
    prime: K256 { name: 'k256', p: [BN], n: 256, k: [BN], tmp: [BN] }
  }
}
*/

const msg = 1n;
const sig = ec.keyFromPrivate(privateKey).sign(msg);

/*
    Signature {
    r: BN {
        negative: 0,
        words: [
        24369373, 47303750,
        17206659, 53210550,
        42685863, 33526311,
        47149407, 66153456,
        9437792,  3909924
        ],
        length: 10,
        red: null
    },
    s: BN {
        negative: 0,
        words: [
        59563265, 47564126, 26249336, 32654568,
        11416092,  6889894, 27448015, 25946329,
        30656875,  3566472,        0,        0,
                0,        0,        0,        0,
                0,        0,        0,        0,
                0,        0,        0,        0,
                0,        0,        0
        ],
        length: 10,
        red: null
    },
    recoveryParam: 1
    }
*/

// The v value is not necessary for the recovery. it helps to make the recovery more efficient

const isValid = ec.verify(msg, sig, publicKey); // true

const isValid2 = ec.verify("not valid msg", sig, publicKey); // false

// Here is where signature malleability starts

const s = new BN(sig.s);

/*
    `n` is the order of the secp256 k1 group (number of points on the elliptic curve)
    
    The modular nature of secp256 k1 allows us to have an S value that is greater than `n` divided by 2
    which is valid for one of the `r` values and the `s` value that corresponds which is less than `n`
    divided by 2 which is valid for the other `r` value

    S value > N/2
    S value < N/2
*/

// `n` minus s will get that other `s` value that is on the other side of that n divided by 2

const sig2 = {r: sig.r, s: n.sub(s)};

const isValid3 = ec.verify(msg, sig2, publicKey); // true

// solution is to restric the `s` value to a single half of the range of `n`
console.log(isValid3);
